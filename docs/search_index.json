[["index.html", "Statistical Computing Chapter 1 Reviews 1.1 Data Types and Structures 1.2 Data Importing and Exporting 1.3 Data Cleaning 1.4 Data Visualization", " Statistical Computing YOUR NAME HERE 2024-10-23 Chapter 1 Reviews 1.1 Data Types and Structures 1.1.1 Data Types There are different kinds of values in R that can be manipulated in variables. They most commonly used are; strings, numerics(integers and floats) and boolean values. The function class can be used to find the data type. Try it! Before diving deep into data types, lets create a value with a random value for instance age and finds its data type. age &lt;- 27 class(age) ## [1] &quot;numeric&quot; The age is a \"numeric\" data type variable, interesting? Lets explore different data types and their examples; Integers: These are whole numbers without dev=cimal point(e.g., 10, -5). In R, it is specified with the L suffix like 10L. Floats: These are numbers with decimal points(e.g. 3.14, -2.718). R refers them as numerics. Boolean(Logical): True or False values, represented as TRUE or FALSE in R. They are crucial in conditional statements. Strings(Character): These are text values enclosed in quotes(e.g. \"Hello world\" , names like \"John\", \"Mustafa\", \"Patel\", variable names like \"age\", \"gender\", \"salary\") You will often deal with mixed data types when analyzing real-world data sets therefore understanding these will help you handles any data set! Examples Lets have some fun! We will create different variables and find their data types; age &lt;- 34L age &lt;- 34L class(age) ## [1] &quot;integer&quot; weight &lt;- 68.2 weight &lt;- 68.2 class(weight) ## [1] &quot;numeric&quot; name &lt;- \"Mustafa\" name &lt;- &quot;Mustafa&quot; class(name) ## [1] &quot;character&quot; is_winter &lt;- FALSE is_winter &lt;- FALSE class(is_winter) ## [1] &quot;logical&quot; You see how simple it is to find the data type of different variables in R! Remember the class function returns any number whether with decimal or whole as \"numeric\". It only returns \"integer\" when there is a suffix L. Practical Exercise Try out the practical exercise below to test your understanding in data types Find the data type of 98.03 using class() function. Assign the value 98.03 to variable height and find data type of height. There are 27 goats in a field, assign the quantity of goats to a variable goats and find the data type of the variable goats. Remember to add suffix L to the value 27. Find the data type of the value \"school\" using the class() function. Assign your first name to a variable firstname and find its data type. Remember to enclose it in quotation marks Create a variable is_student and assign it the value TRUE. Use the class() function to find its data type. Solution Find the data type of 98.03 using class() function. class(98.03) ## [1] &quot;numeric&quot; Assign the value 98.03 to variable height and find data type of height. height &lt;- 98.03 class(height) ## [1] &quot;numeric&quot; There are 27 goats in a field, assign the quantity of goats to a variable goats and find the data type of the variable goats. Remember to add suffix L to the value 27. goats &lt;- 27L class(goats) ## [1] &quot;integer&quot; Find the data type of the value \"school\" using the class() function. class(&quot;school&quot;) ## [1] &quot;character&quot; Assign your first name to a variable firstname and find its data type. Remember to enclose it in quotation marks firstname &lt;- &quot;Bryant&quot; # Any name will work class(firstname) ## [1] &quot;character&quot; Create a variable is_student and assign it the value TRUE. Use the class() function to find its data type. is_student &lt;- TRUE class(is_student) ## [1] &quot;logical&quot; ________________________________________________________________________________ 1.1.2 Data Structures This is the organization of data into or multiple data values in specific structures, they include vectors, matrix and data frames. Lets explore the mentioned data structures and their examples; Vector: This is a sequence of elements of the same data types(e.g., `c(1, 2, 3) is a numeric vector) Matrix: This is a two-dimensional data structure with rows and columns, where all elements are of the same type(e.g. numbers). Data Frames: This is the most common R data structure for handling tabular data(like an excel sheet). A data frame can contain different data types in each column unlike matrices and vectors. Data frames are central to real-world data analysis. You will work with them to analyze, transform, and visualize data sets, whether you are calculating averages or identifying trends. The is.vector, is.matrix and is.data.frame functions are used to confirm if the variable in question is a vector, matrix or data frame respectively. Examples Lets have some fun! We will create different data structures and find their data types: Create a vector, marks to store the values, 23, 67, 98, 34, 98, 21. Print the vector to the console and use is.vector function to confirm if its a actually a vector. marks = c(23, 67, 98, 34, 98, 21) print(marks) # print to the console ## [1] 23 67 98 34 98 21 is.vector(marks) # find its data structure ## [1] TRUE Create a matrix with values from 1 to 9 and use the is.matrix function to find to confirm if its really a matrix. vector1 = seq(1, 9) # Convert to matrix ## create by column m1=matrix(vector1, ncol=3) print(m1) # print the matrix to the console ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 is.matrix(m1) # confirms if its really a matrix ## [1] TRUE Create a data.frame from the above matrix. Add the column names as \"A\", \"B\", \"C\". Confirm if its really a matrix. var_names &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) # vector to store variable names m1_df &lt;- data.frame(var_names, m1) # create the data frame print(m1_df) #print to the console ## var_names X1 X2 X3 ## 1 A 1 4 7 ## 2 B 2 5 8 ## 3 C 3 6 9 is.data.frame(m1_df) #confirms if its really a data.frame. ## [1] TRUE Practical Exercise 1.2 Data Importing and Exporting Data structures and how to import data into R 1.3 Data Cleaning 1.4 Data Visualization A little bit of data visualization "],["functions.html", "Chapter 2 Functions 2.1 Writing Functions 2.2 Calling the Functions 2.3 Function Documentation 2.4 Hands-on Exercise", " Chapter 2 Functions In programming, functions are like little blocks of code that perform a specific task. Think of them as reusable instructions that you can call whenever you need them. Here’s why functions are super helpful: Avoid repetition: Instead of writing the same code multiple times, you can just call the function. Cleaner code: Your code becomes easier to read and maintain because functions help organize it better. Easier debugging: When something goes wrong, you only need to check the function itself rather than searching through your entire program. Why Use Functions? Imagine having to rewrite a set of instructions every time you need them! With functions, you write the code once and reuse it as many times as you want. A good rule of thumb is: if you expect to run a specific set of instructions more than twice, create a function for it. What Can Functions Do? Functions are flexible and can be used for many different purposes: Take input (called arguments) Process the input based on what the function is meant to do Return a result after completing the task 2.1 Writing Functions Lets take a tour on different types of functions in R before diving deep into writing functions. This will help you understand when to write functions and when to use readily-available functions. There are three main types of functions: User-Defined Functions (UDF) – Custom functions you write for your specific needs. Built-in functions – These come pre-loaded in R. Example: mean() Package functions – Functions from external R packages you can install. Example: ggplot() and select() from ggplot2 and dplyr respectively. 2.1.1 User-Defined Functions The best way to grasp how functions work in R is by creating your own! These are called* User-Defined Functions (UDFs), and they allow you to design custom tasks that fit your needs. In R, functions typically follow this format: function_name &lt;- function(argument_1, argument_2) { # Function body (your instructions go here) return(output) } Let’s break down the key elements: Function Name: This is how you’ll call your function later. When you create a function, you assign it a name and save it as a new object. For example, if you name your function calculate_mean, that’s the name you’ll use every time you want to run the function. Arguments (also called Parameters): Arguments are placed inside the parentheses. They tell the function what input to expect or how to modify its behavior. Think of them as placeholders for the data you’ll provide later when you run the function. Function Body: Inside the curly brackets {}, you’ll write the instructions that the function will follow to accomplish the task. This is the “heart” of the function. Return Statement: The return() function tells R what result to give you after the function finishes its job. It’s optional, but it helps if you want to store the function’s result in a variable. Let’s write a simple function that calculates the mean (average) of two numbers: mean_two_numbers &lt;- function(num_1, num_2) { mean &lt;- (num_1 + num_2) / 2 return(mean) } How to Use the Function: To find the mean of 10 and 20, simply call the function like this: mean_two_numbers(10, 20) ## [1] 15 Let’s add a few more simple tasks: writing a function that calculates the difference between two numbers. Why is this important? Well, imagine you have two values and you want to find their difference—that’s exactly what this function will help us do! # Function to calculate the difference between two numbers calculate_difference &lt;- function(x, y) { # Subtract the second number (y) from the first number (x) difference &lt;- x - y # Return the difference result so we can use it later return(difference) } You see!: x and y are our arguments: These are the two numbers we’ll use in our calculation. The subtraction happens inside the function: We simply subtract y from x and store the result in difference. Finally, we return the difference: This way, we can use the result when we call the function. Now, let’s put it to the test! We’ll run the function with different sets of numbers and see what we get: calculate_difference(10, 5) # 10 - 5 = 5 ## [1] 5 calculate_difference(25, 15) # 25 - 15 = 10 ## [1] 10 calculate_difference(50, 30) # 50 - 30 = 20 ## [1] 20 Notice how easy it is to calculate the difference between any two numbers by just calling our function? That’s the power of writing your own functions—they make life a lot easier! Now, lets make it more interesting! How about a function that greets you by name? We can do the same in R by creating a simple function that takes someone’s name and returns a greeting. Here is how we do it: # Function to greet a student by their name greet_student &lt;- function(student_name) { # Create a personalized greeting greeting &lt;- paste(&quot;Hello&quot;, student_name, &quot;!&quot;) # Return the greeting so we can use it later return(greeting) } Remember! We use student_name as the argument: This is where you pass in the name of the student. We combine \"Hello\" with the name: The paste() function(that is an -in-built function which will discuss later in the course) helps us put the pieces together to form a full sentence. Return the greeting: The function gives us back a customized message, ready to greet anyone! Lets try it out with different names greet_student(&quot;John&quot;) # Hello John! ## [1] &quot;Hello John !&quot; greet_student(&quot;Alice&quot;) # Hello Alice! ## [1] &quot;Hello Alice !&quot; greet_student(&quot;Michael&quot;) # Hello Michael! ## [1] &quot;Hello Michael !&quot; Remember to try it out with your name! Key Takeaways: By writing these two simple functions, you’ve already tackled a lot of important concepts in R! You now know: How to create a function. How to pass arguments (inputs/parameters) to a function. How to return a result that you can use later. Practical Exercise In this exercise, you’ll get hands-on practice creating your own functions in R. Follow the instructions below to write functions that perform specific tasks. Remember to test your functions with different input values! Create a function called add_numbers that takes two arguments, a and b, and returns their sum. Write a function named is_even that takes a single argument, num, and returns \"Even\" if the number is even, or \"Odd\" if it’s odd. Create a function called find_max that takes three arguments and returns the largest of the three numbers. Solution Create a function called add_numbers that takes two arguments, a and b, and returns their sum. # Function to calculate the sum of two numbers sum_two_numbers &lt;- function(x, y) { sum &lt;- x + y return(sum) } # Test the function with different values sum_two_numbers(5, 10) # Output: 15 ## [1] 15 sum_two_numbers(20, 30) # Output: 50 ## [1] 50 sum_two_numbers(100, 200) # Output: 300 ## [1] 300 Write a function named is_even that takes a single argument, num, and returns \"Even\" if the number is even, or \"Odd\" if it’s odd. # Function to check if a number is even or odd check_even_odd &lt;- function(number) { if (number %% 2 == 0) { return(&quot;Even&quot;) } else { return(&quot;Odd&quot;) } } # Test the function with different numbers check_even_odd(4) # Output: &quot;Even&quot; ## [1] &quot;Even&quot; check_even_odd(7) # Output: &quot;Odd&quot; ## [1] &quot;Odd&quot; check_even_odd(10) # Output: &quot;Even&quot; ## [1] &quot;Even&quot; Create a function called find_max that takes three arguments and returns the largest of the three numbers. # Function to find the maximum of three numbers max_of_three &lt;- function(a, b, c) { max_value &lt;- max(a, b, c) # Use the built-in max function return(max_value) # Return the maximum value } # Test the function with different values max_of_three(10, 20, 5) # Output: 20 ## [1] 20 max_of_three(3, 1, 2) # Output: 3 ## [1] 3 max_of_three(7, 15, 12) # Output: 15 ## [1] 15 ________________________________________________________________________________ 2.1.2 Built-in Fuctions We have learned how to create our own user-defined functions (UDFs) to perform specific tasks. Now, let’s dive deeper into R’s capabilities by exploring its built-in functions. These handy tools are readily available for you to use anytime, making your coding experience even smoother. R is packed with a treasure trove of built-in functions that allow you to perform a variety of tasks with just a few simple commands. Whether you’re crunching numbers or analyzing data, these functions are your best friends. Here’s a sneak peek at some of the most useful built-in functions in R: print(): This function displays an R object right on your console. It’s like saying, “Hey, look at this!” print(&quot;Hello Mum&quot;) ## [1] &quot;Hello Mum&quot; min() and max(): Need to find the smallest or largest number in a bunch? These functions will do just that for a numeric vector. sum(): Want to add up a series of numbers? Use sum() to get the total of a numeric vector. mean(): This function calculates the average of your numbers. Perfect for when you need to find the middle ground! range(): Curious about the minimum and maximum values of your numeric vector? range() has you covered. str(): Want to understand the structure of an R object? str() will give you a clear picture of what’s inside. ncol(): If you’re working with matrices or data frames, this function tells you how many columns you have. length(): This one returns the number of items in an R object, whether it’s a vector, a list, or a matrix. Here’s a quick example to show you how easy it is to use these functions with a vector of numbers: v &lt;- c(1, 3, 0.2, 1.5, 1.7) # Create a vector print(v) # Display the vector ## [1] 1.0 3.0 0.2 1.5 1.7 sum(v) # Calculate the total sum ## [1] 7.4 mean(v) # Find the average ## [1] 1.48 length(v) # Get the number of elements ## [1] 5 As you can see, working with R’s built-in functions is straightforward and super helpful. Start experimenting with these functions and watch how they can simplify your coding experience! Key Takeaways: By completing this exercise, you’ve already tackled several important concepts in R! You now know: How to create a vector and use it for calculations. How to utilize built-in functions like sum(), max(), min(), mean(), and length(). How to derive meaningful statistics from data using R’s built-in capabilities R has a wealth of resources on this topic, and as you gain more experience and knowledge, you’ll uncover even more advanced built-in functions that can simplify your programming tasks. Practical Exercise In this exercise, you are required to create a vector named numbers that contains the following values: 4, 8, 15, 16, 23, 42. After creating the vector, you will use various built-in functions to analyze it based on the instructions below; Use the sum() function to calculate the total of the numbers vector. Use the max() function to find the maximum value in the numbers vector. Use the min() function to find the minimum value in the numbers vector. Use the mean() function to calculate the average of the numbers vector. Use the length() function to find out how many elements are in your numbers vector. Solution In this exercise, you are required to create a vector named numbers that contains the following values: 4, 8, 15, 16, 23, 42. After creating the vector, you will use various built-in functions to analyze it based on the instructions below; # Create a vector numbers &lt;- c(4, 8, 15, 16, 23, 42) Use the sum() function to calculate the total of the numbers vector. sum(numbers) ## [1] 108 Use the max() function to find the maximum value in the numbers vector. max(numbers) ## [1] 42 Use the min() function to find the minimum value in the numbers vector. min(numbers) ## [1] 4 Use the mean() function to calculate the average of the numbers vector. mean(numbers) ## [1] 18 Use the length() function to find out how many elements are in your numbers vector. length(numbers) ## [1] 6 ________________________________________________________________________________ 2.1.3 Package Functions Just like we’ve learned about User-Defined and Built-in Functions, R also provides a vast number of additional functions through packages. These packages extend R’s capabilities and allow you to perform specific tasks, from data manipulation to machine learning, with ease. What are R Package Functions? Packages in R are collections of R functions, data, and compiled code that are stored in a well-defined format. While R comes with a set of built-in functions, packages allow you to go beyond the basic functionality. You can install and load packages based on the task you want to accomplish. Think of package functions as tools in a toolbox: not everything is built-in, but by adding specific tools, you can perform new tasks easily. Lets explore how to get started using the functions; Installing and Loading Packages To use functions from a package, you first need to install the package and load it into your R session. install.packages(&quot;package_name&quot;) Every time you start a new R session if you want to use the functions from that package. Load the package by; library(package_name) To put this into real-life action, let’s learn about the dplyr package, which is commonly used for data manipulation. It contains many useful functions to work with data frames or tibbles (a modern version of data frames). Here’s an example of how to install and load dplyr, and use some of its core functions. Install the package install.packages(&quot;dplyr&quot;) # Install it once Load the package library(dplyr) # Load it whenever you need to use it ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union Let’s explore a few package functions from dplyr: select(): Chooses specific columns from a dataset. filter(): Filters rows based on conditions. mutate(): Adds new variables (columns) or modifies existing ones. summarise(): Summarizes data, such as calculating the mean or total We will create a data frame to demonstrate how to use functions from the dplyr package. # Create a data frame for demonstration data &lt;- data.frame( Name = c(&quot;John&quot;, &quot;Jane&quot;, &quot;David&quot;, &quot;Anna&quot;), Age = c(28, 34, 22, 19), Score = c(85, 90, 88, 92) ) # 1. Select only the Name and Score columns selected_data &lt;- select(data, Name, Score) selected_data ## Name Score ## 1 John 85 ## 2 Jane 90 ## 3 David 88 ## 4 Anna 92 # 2. Filter rows where Score is greater than 88 filtered_data &lt;- filter(data, Score &gt; 88) filtered_data ## Name Age Score ## 1 Jane 34 90 ## 2 Anna 19 92 # 3. Add a new column that increases Score by 10 mutated_data &lt;- mutate(data, New_Score = Score + 10) mutated_data ## Name Age Score New_Score ## 1 John 28 85 95 ## 2 Jane 34 90 100 ## 3 David 22 88 98 ## 4 Anna 19 92 102 # 4. Calculate the average age summary_data &lt;- summarise(data, Average_Age = mean(Age)) summary_data ## Average_Age ## 1 25.75 In this example, we used functions from the dplyr package to select columns, filter rows, modify data, and summarize it! Key Takeaways: By learning about R package functions, you’ve unlocked even more tools to work efficiently in R. Here’s what you’ve learned today: How to install and load R packages. How to use package functions like those in dplyr for data manipulation. How to perform tasks like selecting columns, filtering data, and summarizing values. Packages in R allow you to extend the functionality of the base language for specific tasks. With packages, R becomes an even more powerful tool, allowing you to work with more advanced data sets and perform complex operations with ease! Practical Exercise In this exercise, you will use the functions from the dplyr package to manipulate the iris data set. Remember the dplyr package is installed by: install.packages(&quot;dplyr&quot;) and is loaded by: library(dplyr) The iris data set is loaded by data(&quot;iris&quot;) # view the first few columns head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa Solve the following questions; Use the select function to select the Sepal.Length, Sepal.Width, and Species columns. Use the filter function to filter rows where Sepal.Length is greater than 5. Use the mutate function to create a new column Sepal.Ratio that divides Sepal.Length by Sepal.Width. Solution In this exercise, you will use the functions from the dplyr package to manipulate the iris data set. Remember the dplyr package is installed by: install.packages(&quot;dplyr&quot;) and is loaded by: library(dplyr) The iris data set is loaded by data(&quot;iris&quot;) # view the first few columns head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa Solve the following questions; Use the select function to select the Sepal.Length, Sepal.Width, and Species columns. selected_iris &lt;- select(iris, Sepal.Length, Sepal.Width, Species) head(selected_iris) ## Sepal.Length Sepal.Width Species ## 1 5.1 3.5 setosa ## 2 4.9 3.0 setosa ## 3 4.7 3.2 setosa ## 4 4.6 3.1 setosa ## 5 5.0 3.6 setosa ## 6 5.4 3.9 setosa Use the filter function to filter rows where Sepal.Length is greater than 5. filtered_iris &lt;- filter(iris, Sepal.Length&gt;5) head(filtered_iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 5.4 3.9 1.7 0.4 setosa ## 3 5.4 3.7 1.5 0.2 setosa ## 4 5.8 4.0 1.2 0.2 setosa ## 5 5.7 4.4 1.5 0.4 setosa ## 6 5.4 3.9 1.3 0.4 setosa Use the mutate function to create a new column Sepal.Ratio that divides Sepal.Length by Sepal.Width. updated_iris &lt;- mutate(iris, Sepal.Ratio=Sepal.Length/Sepal.Width) head(updated_iris$Sepal.Ratio) ## [1] 1.457143 1.633333 1.468750 1.483871 1.388889 1.384615 ________________________________________________________________________________ 2.1.4 Type of arguments in R functions Now that we’ve learned and explored different types of functions, let’s dive into function arguments to strengthen your understanding of writing functions. Arguments are essential components of any function. Although it’s possible to write a function without parameters, like the example below, most functions do require arguments to tell them what data to process hello &lt;- function() { print(&#39;Hello, my friend&#39;) } Why Arguments Matter Arguments are the input for functions. They allow us to give the function specific values to work with. If we want a function to handle different cases or data, arguments give us that flexibility. When defining arguments, you include them inside the parentheses of the function definition, separated by commas. Generally, functions with more arguments tend to be more complex, but they also offer greater control over what the function does. # Creating a function with arguments my_function &lt;- function(argument1, argument2){ # function body } Handling Missing Arguments Whenever you create a function with parameters, you must provide the values for those parameters when calling the function. Otherwise, R will return an error. For example, if you forget to supply both numbers in a function to calculate their mean, the function won’t work. But you can avoid this issue by using default arguments. These are preset values that the function will use if you don’t provide them during the call. Let’s modify our mean function to demonstrate: mean_two_numbers &lt;- function(num_1, num_2 = 30) { mean &lt;- (num_1 + num_2) / 2 return (mean) } In this version, if you only provide one value when calling the function, R will automatically use the default value for the second number (which is 30 in this case): mean_two_numbers(num_1 = 10) ## [1] 20 You now understand how arguments work and the importance of default values in making functions more flexible and error-proof. Practical Exercise Create a function greet that prints a simple message like \"Hello, welcome to R programming!\". Write a function multiply_numbers that takes two arguments, a and b, and returns the product of these numbers Create a function calculate_total that accepts two arguments, price and tax_rate. Set a default value of tax_rate = 0.15 (15%). Solution Create a function greet that prints a simple message like \"Hello, welcome to R programming!\". greet &lt;- function() { print(&quot;Hello, welcome to R programming!&quot;) } # Call the function greet() ## [1] &quot;Hello, welcome to R programming!&quot; Write a function multiply_numbers that takes two arguments, a and b, and returns the product of these numbers. multiply_numbers &lt;- function(a, b) { return(a * b) } # Call the function multiply_numbers(6, 8) ## [1] 48 Create a function calculate_total that accepts two arguments, price and tax_rate. Set a default value of tax_rate = 0.15 (15%). calculate_total &lt;- function(price, tax_rate = 0.15) { total &lt;- price + (price * tax_rate) return(total) } # Call the function calculate_total(price=160) ## [1] 184 ________________________________________________________________________________ 2.1.5 Understanding Return Values in R Functions In many programming languages, functions take data as input and produce some result as output. Often, you must use a return statement to explicitly give back the result. Otherwise, the value might only be visible inside the function and not available to use later. But in R, the situation is a little more relaxed! In R, a function will always return a value that can be stored in a variable, even without a return statement. However, for clarity and good practice, it’s still helpful to include return to show your intent. Let’s walk through an example: mean_sum &lt;- function(num_1, num_2) { mean &lt;- (num_1 + num_2) / 2 sum &lt;- num_1 + num_2 return(list(mean = mean, sum = sum)) } Now, calling the function: results &lt;- mean_sum(10, 20) print(results) # You&#39;ll see both the mean and sum printed ## $mean ## [1] 15 ## ## $sum ## [1] 30 2.2 Calling the Functions In previous sections, we’ve seen how to call functions with different arguments. Now, let’s dig a little deeper into how R works behind the scenes when you pass arguments to a function. R allows two main ways of passing arguments: By position – The arguments are passed in the same order as the function definition. By name – You explicitly mention the argument name and its value. You can also mix these two strategies! Let’s explore these options using an example. Here’s a simple function that takes two arguments: name and surname. hello &lt;- function(name, surname) { print(paste(&#39;Hello&#39;, name, surname)) } Lets call the function using different strategies; By Position You pass the arguments in the exact order the function expects. hello(&#39;Jane&#39;, &#39;McCain&#39;) ## [1] &quot;Hello Jane McCain&quot; By Name When using this method, the order doesn’t matter. You just specify the argument names. hello(surname = &#39;McCain&#39;, name = &#39;Jane&#39;) ## [1] &quot;Hello Jane McCain&quot; Mixing Position and Name You can mix both approaches. Named arguments are matched first, then the remaining ones are matched by position hello(surname = &#39;McCain&#39;, &#39;Jane&#39;) ## [1] &quot;Hello Jane McCain&quot; This flexibility can make your code easier to read and maintain, especially when functions have many arguments! 2.3 Function Documentation Finally when writing functions, it’s always a good idea to provide documentation to guide users on how to use the function. This is especially important when dealing with complex functions or when the function is shared with others. One simple way to add documentation is by including comments in the body of your function. These comments explain what each part of the function does. This is an informal method, but it helps both you and others quickly understand what’s happening in the function. Here’s an example: hello &lt;- function(name, surname) { # Say hello to a person with their name and surname print(paste(&#39;Hello,&#39;, name, surname)) } If you call the function without executing it, you’ll see its structure along with the comments: hello ## function(name, surname) { ## # Say hello to a person with their name and surname ## print(paste(&#39;Hello,&#39;, name, surname)) ## } If your function is part of a larger package and you want it to be properly documented, you should write formal documentation in a separate .Rd file. These files store structured documentation, which you can access using ?function_name in R, similar to the help file you see for built-in functions like ?mean. Formal documentation includes details such as: Function name and description. Arguments and their roles. Examples of how to use the function. Output that the function returns. This approach ensures that users can easily understand and use your function, even in complex packages. 2.4 Hands-on Exercise You will attempt this hands-on exercise to confirm your understanding of functions. For one of the functions you created, add comments inside the function to explain what each part of the function does. Create a User-Defined Function (UDF) named calculate_area that takes two arguments: length and width. The function should return the area of a rectangle. Create a vector named values with the numbers 4, 8, 15, 16, 23, 42. Use the built-in sum() function to calculate the total of the values vector and print the result. Write a function named greet that takes one argument, student_name, and prints a greeting. Modify the function to have a default argument that greets a \"Student\" if no name is provided. Create a function named mean_and_median that takes a numeric vector as an argument and returns both the mean and median of that vector as a list. Solution Create a User-Defined Function (UDF) named calculate_area that takes two arguments: length and width. The function should return the area of a rectangle. calculate_area &lt;- function(length, width) { # Calculate the area by multiplying length and width area &lt;- length * width # Return the calculated area return(area) } # Example usage of the calculate_area function area_result &lt;- calculate_area(5, 10) # Length: 5, Width: 10 print(paste(&quot;Area of rectangle:&quot;, area_result)) ## [1] &quot;Area of rectangle: 50&quot; Create a vector named values with the numbers 4, 8, 15, 16, 23, 42. Use the built-in sum() function to calculate the total of the values vector and print the result. values &lt;- c(4, 8, 15, 16, 23, 42) # Use the built-in sum() function to calculate the total of the values vector total &lt;- sum(values) # Print the result print(paste(&quot;Total of values vector:&quot;, total)) ## [1] &quot;Total of values vector: 108&quot; Write a function named greet that takes one argument, student_name, and prints a greeting. Modify the function to have a default argument that greets a \"Student\" if no name is provided. greet &lt;- function(student_name = &quot;Student&quot;) { # Print a greeting using the provided name or default to &quot;Student&quot; print(paste(&quot;Hello,&quot;, student_name)) } # Example usage of the greet function with a provided name greet(&quot;John&quot;) # Should print &quot;Hello, John&quot; ## [1] &quot;Hello, John&quot; # Example usage of the greet function without providing a name greet() ## [1] &quot;Hello, Student&quot; Create a function named mean_and_median that takes a numeric vector as an argument and returns both the mean and median of that vector as a list. mean_and_median &lt;- function(num_vector) { # Calculate the mean of the vector mean_value &lt;- mean(num_vector) # Calculate the median of the vector median_value &lt;- median(num_vector) # Return both mean and median as a list return(list(mean = mean_value, median = median_value)) } # Example usage of the mean_and_median function results &lt;- mean_and_median(c(12, 19, 21, 14, 09)) # Print the results print(paste(&quot;Mean:&quot;, results$mean, &quot;, Median:&quot;, results$median)) ## [1] &quot;Mean: 15 , Median: 14&quot; ________________________________________________________________________________ "],["group-manipulation.html", "Chapter 3 Group Manipulation 3.1 Apply Family 3.2 Aggregate Plyr 3.3 Data Reshaping", " Chapter 3 Group Manipulation 3.1 Apply Family 3.2 Aggregate Plyr 3.3 Data Reshaping "],["general-statistics.html", "Chapter 4 General Statistics", " Chapter 4 General Statistics "],["simple-linear-regression.html", "Chapter 5 Simple Linear Regression 5.1 Basics of Wilkinson-Rogers Notation (y ~ x), Linear Regression 5.2 Scatterplots with Regression Lines, Reading lm() Output 5.3 Confidence Intervals for Regression Coefficients, Testing Coefficients 5.4 Identifying Points in a Plot", " Chapter 5 Simple Linear Regression Welcome to the world of Simple Linear Regression! 🎉 This statistical technique is super handy when you want to explore the relationship between two continuous variables. Essentially, it helps us predict the value of one variable based on the value of another. For example, imagine you want to predict a student’s exam score based on the number of hours they studied. Here, the hours studied are the independent variable (or predictor), and the exam score is the dependent variable (or response). What is Simple Linear Regression? In simple linear regression, we fit a straight line (called the regression line) through the data points. This line is defined by the equation: \\[y = mx + b\\] Where: \\(y\\) is the predicted value (dependent variable). \\(m\\) is the slope of the line (how much \\(y\\) changes for a unit change in \\(x\\)). \\(x\\) is the independent variable. \\(b\\) is the y-intercept (the value of \\(y\\) when \\(x\\) is 0). Let’s use the built-in mtcars data set in R to demonstrate how to perform simple linear regression. Load the data set # Load the mtcars dataset data(mtcars) # View the first few rows of the dataset head(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 Fit the simple linear regression model that will predict mpg (miles per gallon) based on wt (the weight of the car). # Fit the linear regression model model &lt;- lm(mpg ~ wt, data = mtcars) Get the model summary to get important information about the model we just fitted. # Get the summary of the model summary(model) ## ## Call: ## lm(formula = mpg ~ wt, data = mtcars) ## ## Residuals: ## Min 1Q Median 3Q Max ## -4.5432 -2.3647 -0.1252 1.4096 6.8727 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 37.2851 1.8776 19.858 &lt; 2e-16 *** ## wt -5.3445 0.5591 -9.559 1.29e-10 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 3.046 on 30 degrees of freedom ## Multiple R-squared: 0.7528, Adjusted R-squared: 0.7446 ## F-statistic: 91.38 on 1 and 30 DF, p-value: 1.294e-10 Plot the data and regression line to understand the relationship # Plot the data points plot(mtcars$wt, mtcars$mpg, main = &quot;Simple Linear Regression&quot;, xlab = &quot;Weight of the Car (wt)&quot;, ylab = &quot;Miles Per Gallon (mpg)&quot;, pch = 19, col = &quot;blue&quot;) # Add the regression line abline(model, col = &quot;red&quot;) Predictions can be made based on the data. Lets predict the mpg for car that weighs 3.5 tons # Predict mpg for a car that weighs 3.5 tons new_data &lt;- data.frame(wt = 3.5) predicted_mpg &lt;- predict(model, new_data) print(paste(&quot;Predicted MPG for a car weighing 3.5 tons:&quot;, round(predicted_mpg, 2))) ## [1] &quot;Predicted MPG for a car weighing 3.5 tons: 18.58&quot; 5.1 Basics of Wilkinson-Rogers Notation (y ~ x), Linear Regression 5.2 Scatterplots with Regression Lines, Reading lm() Output 5.3 Confidence Intervals for Regression Coefficients, Testing Coefficients 5.4 Identifying Points in a Plot "],["reproducibility-and-report-with-r-markdown.html", "Chapter 6 Reproducibility and Report with R Markdown", " Chapter 6 Reproducibility and Report with R Markdown "],["r-shiny.html", "Chapter 7 R Shiny 7.1 Structure of a Shiny App", " Chapter 7 R Shiny Shiny is a fantastic R package that allows you to easily create interactive web applications (or “apps”) directly from R. In this lesson, we’ll dive right into how to start building Shiny apps. First things first, if you haven’t installed the Shiny package yet, simply open R, make sure you’re connected to the internet, and run the following command: install.packages(&quot;shiny&quot;) Shiny also integrates with another package called bslib, which helps in creating visually appealing user interfaces (UIs). To explore more about it, you can check out its documentation here. Here is an example of an R shiny app The Shiny package comes with several pre-built examples that showcase how Shiny works in action. Each example is a fully functional Shiny app. The Hello Shiny example, for instance, generates a histogram using R’s faithful data set. The histogram’s bin count can be adjusted by the user through a slider, and the app instantly updates based on their selection. This example is perfect for learning the basics of Shiny app structure and building your very first app. To try it out, just run the following commands in R: library(shiny) runExample(&quot;01_hello&quot;) 7.1 Structure of a Shiny App Shiny apps are typically organized in a single script called app.R, which resides in a designated folder (for example, newdir/). You can run the app by executing runApp(\"newdir\"). The app.R file consists of three main components: A User Interface Object A Server Function A Call to the shinyApp Function 7.1.1 User Interface(ui) The user interface (ui) object defines the layout and visual aspects of your app. Below is the ui object used in the Hello Shiny example: library(shiny) library(bslib) ## ## Attaching package: &#39;bslib&#39; ## The following object is masked from &#39;package:utils&#39;: ## ## page # Define UI for app that draws a histogram ---- ui &lt;- page_sidebar( # App title ---- title = &quot;Hello Shiny!&quot;, # Sidebar panel for inputs ---- sidebar = sidebar( # Input: Slider for the number of bins ---- sliderInput( inputId = &quot;bins&quot;, label = &quot;Number of bins:&quot;, min = 1, max = 50, value = 30 ) ), # Output: Histogram ---- plotOutput(outputId = &quot;distPlot&quot;) ) 7.1.2 Server Here i the server function for the Hello Shiny Example: # Define server logic required to draw a histogram ---- server &lt;- function(input, output) { # Histogram of the Old Faithful Geyser Data ---- # with requested number of bins # This expression that generates a histogram is wrapped in a call # to renderPlot to indicate that: # # 1. It is &quot;reactive&quot; and should automatically # re-execute when inputs (input$bins) change # 2. Its output type is a plot output$distPlot &lt;- renderPlot({ x &lt;- faithful$waiting bins &lt;- seq(min(x), max(x), length.out = input$bins + 1) hist(x, breaks = bins, col = &quot;#007bc2&quot;, border = &quot;white&quot;, xlab = &quot;Waiting time to next eruption (in mins)&quot;, main = &quot;Histogram of waiting times&quot;) }) } At its core, the server function in the Hello Shiny example is quite straightforward. It performs some calculations and generates a histogram based on the specified number of bins. However, you’ll notice that most of the script is wrapped in a call to renderPlot. The comment above the function provides some explanation, but don’t worry if it seems unclear; we will explore this concept in greater detail later. Before you start experimenting with the Hello Shiny app and reviewing its source code, remember that your app.R file should begin with loading the Shiny package and conclude with a call to shinyApp: library(shiny) # See above for the definitions of ui and server ui &lt;- ... server &lt;- ... shinyApp(ui = ui, server = server) While the Hello Shiny app is running, your R session will be occupied and won’t accept other commands. R is actively monitoring the app and processing its reactions. To regain access to your R session, press the escape key or click the stop icon located in the upper right corner of the RStudio console panel. How that you have known how to create an RShiny app, lets create a simple temperature converter that will convert temperature from Celcius to Farenheit. library(shiny) # Define UI for the Temperature Converter app ui &lt;- fluidPage( titlePanel(&quot;Temperature Converter&quot;), sidebarLayout( sidebarPanel( numericInput(&quot;temp_input&quot;, &quot;Temperature:&quot;, value = 0), selectInput(&quot;temp_scale&quot;, &quot;Select scale:&quot;, choices = c(&quot;Celsius to Fahrenheit&quot;, &quot;Fahrenheit to Celsius&quot;)), actionButton(&quot;convert&quot;, &quot;Convert&quot;) ), mainPanel( textOutput(&quot;result&quot;) ) ) ) # Define server logic for the Temperature Converter server &lt;- function(input, output) { observeEvent(input$convert, { if (input$temp_scale == &quot;Celsius to Fahrenheit&quot;) { result &lt;- (input$temp_input * 9/5) + 32 output$result &lt;- renderText({ paste(input$temp_input, &quot;°C =&quot;, round(result, 2), &quot;°F&quot;) }) } else { result &lt;- (input$temp_input - 32) * 5/9 output$result &lt;- renderText({ paste(input$temp_input, &quot;°F =&quot;, round(result, 2), &quot;°C&quot;) }) } }) } # Run the app shinyApp(ui = ui, server = server) Practical Exercise "],["building-r-packages.html", "Chapter 8 Building R Packages", " Chapter 8 Building R Packages "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
